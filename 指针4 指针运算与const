///一个变量可以有无数个指针

///指针可以赋值运算
// int a, *pa = &a, *pb; pb = pa;
//这里是定义了一个整数类型的a，然后定义一个指针*pa储存a的地址，
// 然后又定义了一个*pb指针，再把pa的地址赋值给了pb  （指针是可以这样直接等于号赋值的）

///
/*
int x = 3， y = 0，*px = &x;

y = *px + 5;   ////等于8
y = ++*px;     ////等于4
y = *px++;     这里有说法，加不加括号的问题///先把*px的值赋给y然后自己的指针再往后面走

*px++和（*px）++的区别
不加括号加一相当于是指针往后面走了，例如0x100 变成了0x104
加括号相当于原来的值加了一
*/

//////数组名就是数组首元素地址

/////用指针实现strcpy的功能

#include <stdio.h>

void mystrcpy(char* dest, const char* src) 
{
	while ((*dest++ = *src++) != '\0');
	{
		
		
	/// 后缀递增 ++ 的优先级高于解引用 *，而赋值 = 的优先级最低。
	/// 因此，表达式 *dest++ = *src++ 被解析为
	/// *(dest++) = *(src++);
	/// *(dest++)：首先，dest 当前指向的位置被解引用，即 *dest。
	/// 这表示我们将向 dest 指针当前指向的位置写入数据。
	///	*(src++)：同时，src 当前指向的位置被解引用，即* src。
	/// 这表示我们从 src 指针当前指向的位置读取数据。
	/// 将 *src 的值赋给 *dest，即将源字符串当前字符复制到目标字符串的当前字符位置
	/// 这个是发生在赋值以后dest++：在解引用操作完成后，dest 指针会递增，指向下一个字符的位置。
	///	src++：同样，src 指针也会递增，指向下一个字符的位置。

    ////终止条件：当 *src 被复制到 *dest 并且 *src 是 '\0' 时，循环终止。
    ///停止位置：函数只检查源字符串 src 中的 '\0'，而不关心目标字符串 dest 中是否已经有 '\0'
	}
}
int main()
{
	char s1[32] = "Hello";
	char s2[32] = "123454678";
	mystrcpy(s2, s1);

	printf("%s\n", s2);
	return 0;
}
///s1 被初始化为 "Hello"，
///在内存中的表示为 {'H', 'e', 'l', 'l', 'o', '\0', ...}。
/// s2 被初始化为 "123454678"，在内存中的表示为 
/// {'1', '2', '3', '4', '5', '4', '6', '7', '8', '\0', ...}。
///C 语言中的字符串是以 '\0' 作为终止符的。printf 函数在遇到 '\0' 后会停止打印。
/// 因此，即使 s2 的后续内容仍然存在于内存中，printf 只会显示从字符串开头到第一个 '\0' 之间的内容。


////////////////////////
//代码中的const
/*
const char* src
src 是一个指向常量字符的指针
不能修改指针指向的数据：通过 src 指针，程序不能修改 src 所指向的字符内容。
例如，src[0] = 'A'; 是不允许的，会导致编译错误
/////////
可以修改指针本身：虽然 src 指向的数据是 const，
但指针 src 本身是可以改变的，即可以让 src 指向其他地址
///////////////
const int x = 10;
// x = 20; // 错误，x 是常量，不能被修改
//////////////
修饰指针指向的数据（指针指向的数据不可修改）
const int* p = &x;
// *p = 20; // 错误，不能通过 p 修改 x 的值
p = &y; // 可以，p 本身不是常量指针，可以指向其他地址
解释：p 是一个指向常量整数的指针。通过 p 不能修改它指向的数据，但可以让 p 指向其他地址
////////////////
修饰指针本身（指针本身不可修改）
int* const p = &x;
*p = 20; // 可以，修改 x 的值
// p = &y; // 错误，p 是常量指针，不能指向其他地址
解释：p 是一个常量指针，指向一个整数。可以通过 p 修改它指向的数据，但不能改变 p 本身指向的地址
//////////////


////////////
同时修饰指针和指针指向的数据（都不可修改）
const int* const p = &x;
// *p = 20; // 错误，不能修改 x 的值
// p = &y; // 错误，p 是常量指针，不能指向其他地址
解释：p 是一个指向常量整数的常量指针。既不能通过 p 修改它指向的数据，也不能改变 p 本身指向的地址。
//////////////////
在函数参数中使用 const
void printString(const char* str) {
	// str[0] = 'A'; // 错误，不能修改 str 指向的数据
	printf("%s\n", str);
}
解释：函数 printString 接受一个指向常量字符的指针，保证函数内部不会修改传入的字符串内容，提高代码的安全性和可读性。
///////////////////
const 与数组
void processArray(const int arr[], int size) {
	// arr[0] = 10; // 错误，不能修改数组元素
	for(int i = 0; i < size; i++) {
		printf("%d ", arr[i]);
	}
}
解释：函数 processArray 接受一个指向常量整数数组的指针，保证函数不会修改数组中的元素。
*/

总结一下上面指针与const的关系。
例如const int* p = &x;  这里的话呢const修饰的是*p *p是值，所以指针指向的数据不可修改不能修改
const int* p：表示 p 是一个指向 int 类型常量的指针。

*p 是常量：通过 p 访问到的值是 const，因此不能修改 *p 指向的数据（即 x 的值）


///////////////////////
*p 是 值，而 p 是 地址
int x = 10;
const int* p = &x;
p 是一个指向 const int 的指针，表示 p 存储的是一个指向 int 类型变量 x 的地址。
*p 是通过指针 p 获取 x 的值，即解引用操作，会返回 x 的值（在此例中为 10）。
*p 是值。它是指针 p 指向的 数据值，而不是地址 比如
int y = *p;  // 这里 y 得到的是 *p 指向的值，即 x 的值
*p 是解引用操作，返回指针指向的数据值
///////////////
